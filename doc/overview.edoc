%% -*- mode:html -*-

@author Fred Youhanaie <fyrlang@anydata.co.uk>
@copyright 2021 Fred Youhanaie
@version 0.1.0

@doc

<h3>Introduction</h3>

<p>`pnml' is an Erlang module for processing Petri Net Markup Language
  (PNML) files.
</p>

<h4>PNML</h4>

<p>PNML is an XML based mark up language that is used for defining
  Petri Net models and acts as an interchange format for Petri net
  based tools.
</p>

<p>To learn more about `PNML'
  see <a href="http://www.pnml.org/">http://www.pnml.org/</a>. Also,
  the following two papers provide good introductions to the markup
  language:
</p>

<ul>
  <li>L.M. Hillah and E. Kindler and F. Kordon and L. Petrucci and
  N. Tr√®ves, A primer on the Petri Net Markup Language and ISO/IEC
  15909-2, [<a href="http://www.pnml.org/papers/pnnl76.pdf">PDF</a>]
  </li>

  <li>Michael Weber and Ekkart Kindler, The Petri Net Markup Language,
    2003 [<a href="http://www.pnml.org/papers/PNML_LNCS.pdf">PDF</a>]
  </li>
</ul>

<h4>Petri Nets</h4>

<p>To quote from the description on Wikipedia:
</p>

<blockquote>
  <p><i>A Petri net, also known as a place/transition (PT) net, is one
    of several mathematical modeling languages for the description of
    distributed systems. It is a class of discrete event dynamic
    system.</i>
  </p>
</blockquote>

<p>To learn more about Petri Nets follow the links listed below:
</p>

<ul>

  <li><a href="https://en.wikipedia.org/wiki/Petri_net">
      https://en.wikipedia.org/wiki/Petri_net</a>
  </li>

  <li><a href="https://www.informatik.uni-hamburg.de/TGI/PetriNets/index.php">
      https://www.informatik.uni-hamburg.de/TGI/PetriNets/index.php</a>
  </li>

  <li><a href="http://www.scholarpedia.org/article/Petri_net">
      http://www.scholarpedia.org/article/Petri_net</a>
  </li>

</ul>

<h3>Module Overview</h3>

<p>The main functions of the module are `read/1,2'. They parse and
  process the document using the `xmerl_sax_parser:file/2'
  function. This function is passed an event callback function,
  `event_cb/3', which is called for every SAX event generated by the
  parser.
</p>

<p>
  In turn, `event_cb/3' calls the supplied handler function for the
  user based processing of the PNML (XML) elements. However,
  `event_cb/3' does not pass all the SAX events to the
  handler. Currently, we are only interested in the three events
  `startElement', `endElement' and `characters', the rest of the
  events are skipped. See the `xmerl_sax_parser' documentation for
  details of the event defintions.
</p>

<p>
  Both `read/1,2' functions take a filename that is expected to
  contain a valid PNML document. `read/1' will use the default handler
  to process the PNML elements, while `read/2' will expect an
  additional tuple argument, `{Fun, State}', to be supplied. The tuple
  should contain a handler function and the initial value for the
  handler specific state. See below for a description of the handler
  functions.
</p>

<p>Once processing has concluded successfully, the final contents of
  the state variable from the handler is returned.
</p>

<h4>The Element Handler</h4>

<p>The client code should supply a handler function to `pnml:read/2'
  for processing the individual PNML elements.
</p>

<p>The handler is a function that takes two arguments, the first
  indicates the type of the element along with type dependent values,
  while the second argument is the contents of the state variable at
  the time of the call.
</p>

<p>The first argument is a tuple whose contents depends on the type of
  SAX parser event. These are as follows:
</p>

<ul>
  <li>`{el_begin, Tag, Attrs}' corresponds to a `startElement' event,
    which signals a `<Tag ...>' element. Where `Tag' is an `atom'
    corresponding to the element tag, such as `net', `place',
    `transition' etc, and `Attrs' is the list of attributes from the
    `startElement' event. The attributes can be converted to a map of
    attribute name/value pairs using the `pnml:attr_map/1' function.
  </li>

  <li>`{el_end, Tag}' corresponds to the `endElement' event, which
    signals the `</Tag>' element. It can be used to finish off any
    outstanding work for this element.
  </li>

  <li>`{el_text, Text}' corresponds to the `characters' event, which
    is the text within an element. Most commonly this is an integer
    corresponding to the `initialMarking' of a `place' or the
    `inscription' of an `arc'.
  </li>
</ul>

<p>Associated with each handler is a state variable that is
  initialized during the call to `pnml:read/2'. The current contents
  of the state variable is passed to the handler, which should return
  it, optionally updated, for the future calls to the handler.
</p>

<p>The structure of the state variable is entirely dependent on the
  handler, for example `h_count' will maintain a map where the keys
  are the PNML element tags and the values are counts of the
  corresponding tags encountered so far.
</p>

<p>A number of sample handlers have been provided with the
  module. While they have their own uses, they can also be used as
  examples for creating new handlers. `h_null' is the simplest of the
  handlers, it does not do anything with the element, so it can be
  used for testing and benchmarking. `h_logger', as the name implies,
  sends its input to the `logger' with the `notice' level, `h_count'
  will keep a running count of the element tags, i.e. `pnml', `net',
  `place' etc.
</p>

@end
